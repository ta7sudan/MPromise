{"version":3,"file":"MPromise.umd.js","sources":["../src/index.ts"],"sourcesContent":["/* global DEBUG */\ntype Resolve<T> = (val?: T) => void;\ntype Reject = (val?: any) => void;\ntype Revealing<T> = (resolve: Resolve<T>, reject: Reject) => void;\ntype Fulfilled<T> = (val?: T) => any;\ntype Rejected = (val?: any) => any;\ntype Sub = (status: PStatus) => void;\n\n// 2.1 一个 promise 的当前状态必须是以下三个中的一个: pending, fulfilled, rejected.\nconst enum PStatus {\n\tpending,\n\tfulfilled,\n\trejected\n}\n\nconst _status = Symbol('status');\nconst _value = Symbol('value');\nconst _subs = Symbol('subs');\nconst _notify = Symbol('notify');\nconst _depend = Symbol('depend');\nconst _resolve = Symbol('resolve');\nconst setValueAndStatus = Symbol('setValueAndStatus');\n\nfunction runAsync(fn: () => void) {\n\tif (process && process.nextTick) {\n\t\tprocess.nextTick(fn);\n\t} else {\n\t\t// 浏览器环境下为了省事, 就不搞microtask了\n\t\tsetTimeout(fn, 0);\n\t}\n}\n\nexport class MPromise<T> {\n\tprivate [_status]: PStatus;\n\tprivate [_value]?: T;\n\tprivate [_subs]: Sub[];\n\n\t// 可以没有揭示函数, 那promise就永远pending\n\tconstructor(revealing?: Revealing<T>) {\n\t\t// 除了初始化不用setValueAndStatus, 避免触发notify\n\t\tthis[_value] = undefined;\n\t\tthis[_status] = PStatus.pending;\n\t\tthis[_subs] = [];\n\n\t\tif (revealing) {\n\t\t\tlet called = false;\n\t\t\tconst resolve_: Resolve<T> = val => {\n\t\t\t\tif (called) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\tMPromise[_resolve](this, val);\n\t\t\t};\n\t\t\tconst reject_: Reject = val => {\n\t\t\t\tif (called) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\tthis[setValueAndStatus](val, PStatus.rejected);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\trevealing(resolve_, reject_);\n\t\t\t} catch (err) {\n\t\t\t\tif (!called) {\n\t\t\t\t\tthis[setValueAndStatus](err, PStatus.rejected);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// [[Resolve(promise x)]]\n\t// 就拿onFulfilled返回promise这一种情况来讲, 返回的这个promise的值类型\n\t// 由用户决定, 甚至运行时根据不同情况返回不同类型的值, 所以这里x的值应\n\t// 当是any, 而promise的值也一样, 在Promise.resolve的时候就不知道会是什么\n\t// 类型, 所以也是any\n\tprivate static [_resolve](promise: MPromise<any>, x: any): void {\n\t\t// 虽然setValueAndStatus中实际上对状态进行了控制, 不过这里还是判断一下\n\t\t// 避免意外\n\t\tif (promise[_status] !== PStatus.pending) {\n\t\t\treturn;\n\t\t}\n\t\t// 2.3.1. 如果 `promise` 和 `x` 指向同一个对象, 则将 `promise` 置为 rejected, 并用一个 `TypeError` 作为 reason\n\t\tif (promise === x) {\n\t\t\tpromise[setValueAndStatus](new TypeError('promise is same as x'), PStatus.rejected);\n\t\t\t// 2.3.2. 如果 `x` 是一个 promise, 则 `promise` 采用 `x` 的状态\n\t\t} else if (x instanceof MPromise) {\n\t\t\t// 如果x是pending, 则将x添加为promise的依赖\n\t\t\t// 2.3.2.1. 如果 `x` 是 pending 状态, 则 `promise` 必须保持 pending 状态\n\t\t\t// 直到 `x` 变为 fulfilled 或 rejected (之后 `promise` 的状态也跟着变为相应状态).\n\t\t\tif (x[_status] === PStatus.pending) {\n\t\t\t\tx[_depend](status => {\n\t\t\t\t\tpromise[setValueAndStatus](x[_value], status);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// 否则直接修改promise的状态和值\n\t\t\t\t// 2.3.2.2. 如果/当 `x` 是 fulfilled 状态, 则将 `promise` 置为 fulfilled 状态, 并具有和 `x` 一样的 value.\n\t\t\t\t// 2.3.2.3. 如果/当 `x` 是 rejected 状态, 则将 `promise` 置为 rejected 状态, 并具有和 `x` 一样的 reason.\n\t\t\t\tpromise[setValueAndStatus](x[_value], x[_status]);\n\t\t\t}\n\t\t\t// 2.3.3. 否则, 如果 `x` 是一个对象或函数\n\t\t} else if (Object.prototype.toString.call(x) === '[object Object]' || typeof x === 'function') {\n\t\t\tlet then = null;\n\t\t\ttry {\n\t\t\t\t// 2.3.3.1. 令 `then` 为 `x.then`, 即将 `x.then` 赋值给一个临时变量 `then`\n\t\t\t\tthen = x.then;\n\t\t\t} catch (err) {\n\t\t\t\t// 2.3.3.2. 如果取 `x.then` 时抛出了一个异常 `e`, 则将 `promise` 置为 rejected, 并用 `e` 作为它的 reason\n\t\t\t\tpromise[setValueAndStatus](err, PStatus.rejected);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 2.3.3.3. 如果 `then` 是一个函数, 则调用它并用 `x` 作为它的 `this`, 给它传递两个回调函数作为参数, 第一个参数是 `resolvePromise`, 第二个参数是 `rejectPromise`,\n\t\t\tif (typeof then === 'function') {\n\t\t\t\t// 2.3.3.3.3. 如果 `resolvePromise` 和 `rejectPromise` 都被调用了,\n\t\t\t\t// 或多次以相同的参数调用了, 则采用第一次被调用的那个函数(采用应该是指只对第一次的调用按照上面两步的操作执行), 之后的调用都被忽略\n\t\t\t\t// 这个called作为被调用的标记\n\t\t\t\tlet called = false;\n\t\t\t\tconst resolvePromise: Fulfilled<any> = y => {\n\t\t\t\t\tif (called) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcalled = true;\n\t\t\t\t\t// 3.6 检测循环thenalbe\n\t\t\t\t\tif (x === y) {\n\t\t\t\t\t\tpromise[setValueAndStatus](new TypeError('cycle thenable'), PStatus.rejected);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 2.3.3.3.1. 如果/当 `resolvePromise` 被传入参数 `y` 调用时, 则执行 `[[Resolve]](promise, y)`\n\t\t\t\t\tMPromise[_resolve](promise, y);\n\t\t\t\t};\n\t\t\t\tconst rejectPromise: Rejected = r => {\n\t\t\t\t\tif (called) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcalled = true;\n\t\t\t\t\t// 2.3.3.3.2. 如果/当 `rejectPromise` 被传入参数 `r` 调用时, `r` 是一个 reason, 则将 `promise` 置为 rejected, 并用 `r` 作为它的 reason\n\t\t\t\t\tpromise[setValueAndStatus](r, PStatus.rejected);\n\t\t\t\t};\n\t\t\t\ttry {\n\t\t\t\t\t// 2.3.3.3.4. 如果调用 `then` 抛出了一个异常 `e`.\n\t\t\t\t\tthen.call(x, resolvePromise, rejectPromise);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// 2.3.3.3.4.1. 如果 `resolvePromise` 或 `rejectPromise` 已经被调用过了, 则忽略它\n\t\t\t\t\tif (!called) {\n\t\t\t\t\t\t// 2.3.3.3.4.2. 否则将 `promise` 置为 rejected, 并用 `e` 作为其 reason\n\t\t\t\t\t\tpromise[setValueAndStatus](err, PStatus.rejected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 2.3.3.4. 如果 `then` 不是一个函数, 则将 `promise` 置为 fulfilled, 并用 `x` 作为其 value\n\t\t\t\tpromise[setValueAndStatus](x, PStatus.fulfilled);\n\t\t\t}\n\t\t} else {\n\t\t\t// 2.3.4. 如果 `x` 不是一个对象或函数, 则将 `promise` 置为 fulfilled, 并用 `x` 作为其 value\n\t\t\tpromise[setValueAndStatus](x, PStatus.fulfilled);\n\t\t}\n\t}\n\n\t// 讲道理这里x应该可以有个确定的类型, 但是当x\n\t// 是一个promise的时候, 我不知道怎么把promise的值的类型\n\t// 映射到返回值的类型...\n\tpublic static resolve(x: any): MPromise<any> {\n\t\tif (x instanceof MPromise) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn new MPromise<typeof x>(rs => rs(x));\n\t\t}\n\t}\n\n\tpublic static reject(x: any) {\n\t\tif (x instanceof MPromise) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn new MPromise<typeof x>((rs, rj) => rj(x));\n\t\t}\n\t}\n\n\t// 状态和value总是一起改变的, 所以通过统一的私有方法进行设置便于管理\n\tprivate [setValueAndStatus](value: T | undefined, status: PStatus) {\n\t\t// 2.1 的约束\n\t\t// 2.1.1 当处于 pending 状态时, 一个 promise 可以转移到 fulfilled 或 rejected 状态\n\t\t// 2.1.2 and 2.1.3的约束也在这里\n\t\tif (this[_status] === PStatus.pending) {\n\t\t\tthis[_value] = value;\n\t\t\tthis[_status] = status;\n\t\t\t// 2.2.2.2. 它一定不能在 `promise` 状态为 fulfilled 之前被调用\n\t\t\t// 2.2.3.2. 它一定不能在 `promise` 状态为 rejected 之前被调用\n\t\t\t// notify是异步的, 这也确保了2.2.4\n\t\t\t// 2.2.4. `onFulfilled` 或 `onRejected` 只有在执行上下文([execution context](https://es5.github.io/#x10.3))栈中仅剩平台代码时才会被调用\n\t\t\tthis[_notify]();\n\t\t}\n\t}\n\n\tprivate [_depend](cb: Sub): void {\n\t\tthis[_subs].push(cb);\n\t}\n\n\tprivate [_notify](): void {\n\t\trunAsync(() => {\n\t\t\twhile (this[_subs].length) {\n\t\t\t\t// 2.2.2.3. 它最多被调用一次\n\t\t\t\t// 2.2.3.3. 它最多被调用一次\n\t\t\t\t// 2.2.6.1. 如果/当 `promise` 的状态是 fulfilled, 其相应的所有 `onFulfilled` 回调函数必须按照它们通过 `then` 注册的顺序依次调用执行\n\t\t\t\t// 2.2.6.2. 如果/当 `promise` 的状态是 rejected, 其相应的所有 `onRejected` 回调函数必须按照它们通过 `then` 注册的顺序依次调用执行\n\t\t\t\t// 因为callback中会判断自身状态是fulfilled还是rejected,\n\t\t\t\t// 从而根据情况执行onFulfilled和onRejected, 所以这里只\n\t\t\t\t// 需要一个数组就行, 不需要两个, 也避免了需要处理当已经\n\t\t\t\t// 是最终状态时候, 还得清空掉另一个状态的队列的情况, 避免\n\t\t\t\t// 内存泄漏\n\t\t\t\t(<Sub>this[_subs].shift())(this[_status]);\n\t\t\t}\n\t\t});\n\t}\n\n\t// 2.2.1 `onFulfilled` 和 `onRejected` 都是可选的\n\t// 所以then可以没有onFulfilled也可以没有onRejected\n\t// onFulfilled参数的类型需要和Promise的值的类型保持一致\n\t// onRejected参数的类型则没必要一致, 因为可能是Error\n\t// then的返回值是个Promise, 但是Promise的值由onFulfilled的返回值决定\n\t// 而onFulfilled可以返回任意类型, 所以这里应当是一个any类型的Promise\n\tpublic then(onFulfilled?: Fulfilled<T>, onRejected?: Rejected): MPromise<any> {\n\t\t// 2.2.7. `then` 方法必须返回一个 promise\n\t\t// 3.3 通常返回一个新promise\n\t\treturn new MPromise<any>((rs, rj) => {\n\t\t\t// 管他当前Promise是什么状态, 先把自己作为依赖\n\t\t\t// 它可能被Promise链后面的Promise依赖, 也可能被自己依赖\n\t\t\t// 收集依赖异步调用onFulfilled和onRejected\n\t\t\t// 本质上讲, promise每调用一次then注册callback, 就导致promise自身被依赖一次\n\t\t\t// 2.2.2.1. 则它必须在 `promise` 状态为 fulfilled 之后被调用, 它的第一个参数是 `promise` 的 value\n\t\t\t// 2.2.3.1. 则它必须在 `promise` 状态为 rejected 之后被调用, 它的第一个参数是 `promise` 的 reason\n\t\t\tthis[_depend](status => {\n\t\t\t\tif (status === PStatus.fulfilled) {\n\t\t\t\t\t// 2.2.1.1 如果 `onFulfilled` 不是一个函数, 则它必须被忽略\n\t\t\t\t\t// 2.2.2 如果 `onFulfilled` 是一个函数\n\t\t\t\t\tif (typeof onFulfilled === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// 2.2.7.1. 如果 `onFulfilled` 或 `onRejected` 返回一个 value `x`,\n\t\t\t\t\t\t\t// 则运行 Promise 解析处理程序(Promise Resolution Procedure) `[[Resolve]](promise2, x)`\n\t\t\t\t\t\t\t// 隐含了一个事情是then中需要拿到onFulfilled的返回值\n\t\t\t\t\t\t\t// 那就要求onFulfilled和onRejected必须在then的作用域中被调用\n\t\t\t\t\t\t\t// 同时它还得是异步的\n\t\t\t\t\t\t\t// 我只能想到这样的方式\n\t\t\t\t\t\t\t// 2.2.2.1. 则它必须在 `promise` 状态为 fulfilled 之后被调用, 它的第一个参数是 `promise` 的 value\n\t\t\t\t\t\t\t// 2.2.5. `onFulfilled` 和 `onRejected` 必须被作为函数调用(即没有 `this`, 也不是作为构造函数调用)\n\t\t\t\t\t\t\tconst rst = onFulfilled.call(undefined, this[_value]);\n\t\t\t\t\t\t\t// 注意rs包装了[[Resolve(promise, x)]]\n\t\t\t\t\t\t\trs(rst);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t// 2.2.7.2. 如果 `onFulfilled` 或 `onRejected` 抛出了一个异常 `e`, `promise2` 必须转移到 rejected 状态, 并且将 `e` 作为 reason\n\t\t\t\t\t\t\trj(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 2.2.7.3. 如果 `onFulfilled` 不是一个函数并且 `promise1` 是 fulfilled 状态,\n\t\t\t\t\t\t// 则 `promise2` 必须是 fulfilled 状态, 并且它的 value 和 promise1 一样\n\t\t\t\t\t\trs(this[_value]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 2.2.1.2 如果 `onRejected` 不是一个函数, 则它必须被忽略\n\t\t\t\t\t// 2.2.3 如果 `onRejected` 是一个函数\n\t\t\t\t\tif (typeof onRejected === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst rst = onRejected.call(undefined, this[_value]);\n\t\t\t\t\t\t\t// 2.2.7.1. 如果 `onFulfilled` 或 `onRejected` 返回一个 value `x`,\n\t\t\t\t\t\t\t// 则运行 Promise 解析处理程序(Promise Resolution Procedure) `[[Resolve]](promise2, x)`\n\t\t\t\t\t\t\trs(rst);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\trj(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 2.2.7.4. 如果 `onRejected` 不是一个函数并且 `promise1` 是 rejected 状态,\n\t\t\t\t\t\t// 则 `promise2` 必须是 rejected 状态, 并且它的 reason 和 `promise1` 一样\n\t\t\t\t\t\trj(this[_value]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// 如果不是pending, 就立即通知还在队列中未执行的onFulfilled或onRejected\n\t\t\tif (this[_status] !== PStatus.pending) {\n\t\t\t\tthis[_notify]();\n\t\t\t}\n\t\t});\n\t}\n}\n\n// 为了跑测试暴露出来\nexport const resolve = MPromise[_resolve];\n\n// 为了跑测试暴露出来\nexport function reject(promise: MPromise<any>, reason: any) {\n\tpromise[setValueAndStatus](reason, PStatus.rejected);\n}\n"],"names":[],"mappings":"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"}