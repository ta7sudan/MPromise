{"version":3,"file":"MPromise.min.js","sources":["MPromise.js"],"sourcesContent":["/* global DEBUG */\ntype Resolve<T> = (val?: T) => void;\ntype Reject = (val?: any) => void;\ntype Revealing<T> = (resolve: Resolve<T>, reject: Reject) => void;\ntype Fulfilled<T> = (val?: T) => any;\ntype Rejected = (val?: any) => any;\ntype Sub = (status: PStatus) => void;\n\n// 2.1 一个 promise 的当前状态必须是以下三个中的一个: pending, fulfilled, rejected.\nconst enum PStatus {\n\tpending,\n\tfulfilled,\n\trejected\n}\n\nconst _status = Symbol('status');\nconst _value = Symbol('value');\nconst _subs = Symbol('subs');\nconst _notify = Symbol('notify');\nconst _depend = Symbol('depend');\nconst _resolve = Symbol('resolve');\nconst setValueAndStatus = Symbol('setValueAndStatus');\n\nfunction runAsync(fn: () => void) {\n\tif (process && process.nextTick) {\n\t\tprocess.nextTick(fn);\n\t} else {\n\t\t// 浏览器环境下为了省事, 就不搞microtask了\n\t\tsetTimeout(fn, 0);\n\t}\n}\n\nexport class MPromise<T> {\n\tprivate [_status]: PStatus;\n\tprivate [_value]?: T;\n\tprivate [_subs]: Sub[];\n\n\t// 可以没有揭示函数, 那promise就永远pending\n\tconstructor(revealing?: Revealing<T>) {\n\t\t// 除了初始化不用setValueAndStatus, 避免触发notify\n\t\tthis[_value] = undefined;\n\t\tthis[_status] = PStatus.pending;\n\t\tthis[_subs] = [];\n\n\t\tif (revealing) {\n\t\t\tlet called = false;\n\t\t\tconst resolve_: Resolve<T> = val => {\n\t\t\t\tif (called) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\tMPromise[_resolve](this, val);\n\t\t\t};\n\t\t\tconst reject_: Reject = val => {\n\t\t\t\tif (called) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tcalled = true;\n\t\t\t\tthis[setValueAndStatus](val, PStatus.rejected);\n\t\t\t};\n\t\t\ttry {\n\t\t\t\trevealing(resolve_, reject_);\n\t\t\t} catch (err) {\n\t\t\t\tif (!called) {\n\t\t\t\t\tthis[setValueAndStatus](err, PStatus.rejected);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// [[Resolve(promise x)]]\n\t// 就拿onFulfilled返回promise这一种情况来讲, 返回的这个promise的值类型\n\t// 由用户决定, 甚至运行时根据不同情况返回不同类型的值, 所以这里x的值应\n\t// 当是any, 而promise的值也一样, 在Promise.resolve的时候就不知道会是什么\n\t// 类型, 所以也是any\n\tprivate static [_resolve](promise: MPromise<any>, x: any): void {\n\t\t// 虽然setValueAndStatus中实际上对状态进行了控制, 不过这里还是判断一下\n\t\t// 避免意外\n\t\tif (promise[_status] !== PStatus.pending) {\n\t\t\treturn;\n\t\t}\n\t\t// 2.3.1. 如果 `promise` 和 `x` 指向同一个对象, 则将 `promise` 置为 rejected, 并用一个 `TypeError` 作为 reason\n\t\tif (promise === x) {\n\t\t\tpromise[setValueAndStatus](new TypeError('promise is same as x'), PStatus.rejected);\n\t\t\t// 2.3.2. 如果 `x` 是一个 promise, 则 `promise` 采用 `x` 的状态\n\t\t} else if (x instanceof MPromise) {\n\t\t\t// 如果x是pending, 则将x添加为promise的依赖\n\t\t\t// 2.3.2.1. 如果 `x` 是 pending 状态, 则 `promise` 必须保持 pending 状态\n\t\t\t// 直到 `x` 变为 fulfilled 或 rejected (之后 `promise` 的状态也跟着变为相应状态).\n\t\t\tif (x[_status] === PStatus.pending) {\n\t\t\t\tx[_depend](status => {\n\t\t\t\t\tpromise[setValueAndStatus](x[_value], status);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\t// 否则直接修改promise的状态和值\n\t\t\t\t// 2.3.2.2. 如果/当 `x` 是 fulfilled 状态, 则将 `promise` 置为 fulfilled 状态, 并具有和 `x` 一样的 value.\n\t\t\t\t// 2.3.2.3. 如果/当 `x` 是 rejected 状态, 则将 `promise` 置为 rejected 状态, 并具有和 `x` 一样的 reason.\n\t\t\t\tpromise[setValueAndStatus](x[_value], x[_status]);\n\t\t\t}\n\t\t\t// 2.3.3. 否则, 如果 `x` 是一个对象或函数\n\t\t} else if (Object.prototype.toString.call(x) === '[object Object]' || typeof x === 'function') {\n\t\t\tlet then = null;\n\t\t\ttry {\n\t\t\t\t// 2.3.3.1. 令 `then` 为 `x.then`, 即将 `x.then` 赋值给一个临时变量 `then`\n\t\t\t\tthen = x.then;\n\t\t\t} catch (err) {\n\t\t\t\t// 2.3.3.2. 如果取 `x.then` 时抛出了一个异常 `e`, 则将 `promise` 置为 rejected, 并用 `e` 作为它的 reason\n\t\t\t\tpromise[setValueAndStatus](err, PStatus.rejected);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t// 2.3.3.3. 如果 `then` 是一个函数, 则调用它并用 `x` 作为它的 `this`, 给它传递两个回调函数作为参数, 第一个参数是 `resolvePromise`, 第二个参数是 `rejectPromise`,\n\t\t\tif (typeof then === 'function') {\n\t\t\t\t// 2.3.3.3.3. 如果 `resolvePromise` 和 `rejectPromise` 都被调用了,\n\t\t\t\t// 或多次以相同的参数调用了, 则采用第一次被调用的那个函数(采用应该是指只对第一次的调用按照上面两步的操作执行), 之后的调用都被忽略\n\t\t\t\t// 这个called作为被调用的标记\n\t\t\t\tlet called = false;\n\t\t\t\tconst resolvePromise: Fulfilled<any> = y => {\n\t\t\t\t\tif (called) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcalled = true;\n\t\t\t\t\t// 3.6 检测循环thenalbe\n\t\t\t\t\tif (x === y) {\n\t\t\t\t\t\tpromise[setValueAndStatus](new TypeError('cycle thenable'), PStatus.rejected);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\t// 2.3.3.3.1. 如果/当 `resolvePromise` 被传入参数 `y` 调用时, 则执行 `[[Resolve]](promise, y)`\n\t\t\t\t\tMPromise[_resolve](promise, y);\n\t\t\t\t};\n\t\t\t\tconst rejectPromise: Rejected = r => {\n\t\t\t\t\tif (called) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tcalled = true;\n\t\t\t\t\t// 2.3.3.3.2. 如果/当 `rejectPromise` 被传入参数 `r` 调用时, `r` 是一个 reason, 则将 `promise` 置为 rejected, 并用 `r` 作为它的 reason\n\t\t\t\t\tpromise[setValueAndStatus](r, PStatus.rejected);\n\t\t\t\t};\n\t\t\t\ttry {\n\t\t\t\t\t// 2.3.3.3.4. 如果调用 `then` 抛出了一个异常 `e`.\n\t\t\t\t\tthen.call(x, resolvePromise, rejectPromise);\n\t\t\t\t} catch (err) {\n\t\t\t\t\t// 2.3.3.3.4.1. 如果 `resolvePromise` 或 `rejectPromise` 已经被调用过了, 则忽略它\n\t\t\t\t\tif (!called) {\n\t\t\t\t\t\t// 2.3.3.3.4.2. 否则将 `promise` 置为 rejected, 并用 `e` 作为其 reason\n\t\t\t\t\t\tpromise[setValueAndStatus](err, PStatus.rejected);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t// 2.3.3.4. 如果 `then` 不是一个函数, 则将 `promise` 置为 fulfilled, 并用 `x` 作为其 value\n\t\t\t\tpromise[setValueAndStatus](x, PStatus.fulfilled);\n\t\t\t}\n\t\t} else {\n\t\t\t// 2.3.4. 如果 `x` 不是一个对象或函数, 则将 `promise` 置为 fulfilled, 并用 `x` 作为其 value\n\t\t\tpromise[setValueAndStatus](x, PStatus.fulfilled);\n\t\t}\n\t}\n\n\t// 讲道理这里x应该可以有个确定的类型, 但是当x\n\t// 是一个promise的时候, 我不知道怎么把promise的值的类型\n\t// 映射到返回值的类型...\n\tpublic static resolve(x: any): MPromise<any> {\n\t\tif (x instanceof MPromise) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn new MPromise<typeof x>(rs => rs(x));\n\t\t}\n\t}\n\n\tpublic static reject(x: any) {\n\t\tif (x instanceof MPromise) {\n\t\t\treturn x;\n\t\t} else {\n\t\t\treturn new MPromise<typeof x>((rs, rj) => rj(x));\n\t\t}\n\t}\n\n\t// 状态和value总是一起改变的, 所以通过统一的私有方法进行设置便于管理\n\tprivate [setValueAndStatus](value: T | undefined, status: PStatus) {\n\t\t// 2.1 的约束\n\t\t// 2.1.1 当处于 pending 状态时, 一个 promise 可以转移到 fulfilled 或 rejected 状态\n\t\t// 2.1.2 and 2.1.3的约束也在这里\n\t\tif (this[_status] === PStatus.pending) {\n\t\t\tthis[_value] = value;\n\t\t\tthis[_status] = status;\n\t\t\t// 2.2.2.2. 它一定不能在 `promise` 状态为 fulfilled 之前被调用\n\t\t\t// 2.2.3.2. 它一定不能在 `promise` 状态为 rejected 之前被调用\n\t\t\t// notify是异步的, 这也确保了2.2.4\n\t\t\t// 2.2.4. `onFulfilled` 或 `onRejected` 只有在执行上下文([execution context](https://es5.github.io/#x10.3))栈中仅剩平台代码时才会被调用\n\t\t\tthis[_notify]();\n\t\t}\n\t}\n\n\tprivate [_depend](cb: Sub): void {\n\t\tthis[_subs].push(cb);\n\t}\n\n\tprivate [_notify](): void {\n\t\trunAsync(() => {\n\t\t\twhile (this[_subs].length) {\n\t\t\t\t// 2.2.2.3. 它最多被调用一次\n\t\t\t\t// 2.2.3.3. 它最多被调用一次\n\t\t\t\t// 2.2.6.1. 如果/当 `promise` 的状态是 fulfilled, 其相应的所有 `onFulfilled` 回调函数必须按照它们通过 `then` 注册的顺序依次调用执行\n\t\t\t\t// 2.2.6.2. 如果/当 `promise` 的状态是 rejected, 其相应的所有 `onRejected` 回调函数必须按照它们通过 `then` 注册的顺序依次调用执行\n\t\t\t\t// 因为callback中会判断自身状态是fulfilled还是rejected,\n\t\t\t\t// 从而根据情况执行onFulfilled和onRejected, 所以这里只\n\t\t\t\t// 需要一个数组就行, 不需要两个, 也避免了需要处理当已经\n\t\t\t\t// 是最终状态时候, 还得清空掉另一个状态的队列的情况, 避免\n\t\t\t\t// 内存泄漏\n\t\t\t\t(<Sub>this[_subs].shift())(this[_status]);\n\t\t\t}\n\t\t});\n\t}\n\n\t// 2.2.1 `onFulfilled` 和 `onRejected` 都是可选的\n\t// 所以then可以没有onFulfilled也可以没有onRejected\n\t// onFulfilled参数的类型需要和Promise的值的类型保持一致\n\t// onRejected参数的类型则没必要一致, 因为可能是Error\n\t// then的返回值是个Promise, 但是Promise的值由onFulfilled的返回值决定\n\t// 而onFulfilled可以返回任意类型, 所以这里应当是一个any类型的Promise\n\tpublic then(onFulfilled?: Fulfilled<T>, onRejected?: Rejected): MPromise<any> {\n\t\t// 2.2.7. `then` 方法必须返回一个 promise\n\t\t// 3.3 通常返回一个新promise\n\t\treturn new MPromise<any>((rs, rj) => {\n\t\t\t// 管他当前Promise是什么状态, 先把自己作为依赖\n\t\t\t// 它可能被Promise链后面的Promise依赖, 也可能被自己依赖\n\t\t\t// 收集依赖异步调用onFulfilled和onRejected\n\t\t\t// 本质上讲, promise每调用一次then注册callback, 就导致promise自身被依赖一次\n\t\t\t// 2.2.2.1. 则它必须在 `promise` 状态为 fulfilled 之后被调用, 它的第一个参数是 `promise` 的 value\n\t\t\t// 2.2.3.1. 则它必须在 `promise` 状态为 rejected 之后被调用, 它的第一个参数是 `promise` 的 reason\n\t\t\tthis[_depend](status => {\n\t\t\t\tif (status === PStatus.fulfilled) {\n\t\t\t\t\t// 2.2.1.1 如果 `onFulfilled` 不是一个函数, 则它必须被忽略\n\t\t\t\t\t// 2.2.2 如果 `onFulfilled` 是一个函数\n\t\t\t\t\tif (typeof onFulfilled === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t// 2.2.7.1. 如果 `onFulfilled` 或 `onRejected` 返回一个 value `x`,\n\t\t\t\t\t\t\t// 则运行 Promise 解析处理程序(Promise Resolution Procedure) `[[Resolve]](promise2, x)`\n\t\t\t\t\t\t\t// 隐含了一个事情是then中需要拿到onFulfilled的返回值\n\t\t\t\t\t\t\t// 那就要求onFulfilled和onRejected必须在then的作用域中被调用\n\t\t\t\t\t\t\t// 同时它还得是异步的\n\t\t\t\t\t\t\t// 我只能想到这样的方式\n\t\t\t\t\t\t\t// 2.2.2.1. 则它必须在 `promise` 状态为 fulfilled 之后被调用, 它的第一个参数是 `promise` 的 value\n\t\t\t\t\t\t\t// 2.2.5. `onFulfilled` 和 `onRejected` 必须被作为函数调用(即没有 `this`, 也不是作为构造函数调用)\n\t\t\t\t\t\t\tconst rst = onFulfilled.call(undefined, this[_value]);\n\t\t\t\t\t\t\t// 注意rs包装了[[Resolve(promise, x)]]\n\t\t\t\t\t\t\trs(rst);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\t// 2.2.7.2. 如果 `onFulfilled` 或 `onRejected` 抛出了一个异常 `e`, `promise2` 必须转移到 rejected 状态, 并且将 `e` 作为 reason\n\t\t\t\t\t\t\trj(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 2.2.7.3. 如果 `onFulfilled` 不是一个函数并且 `promise1` 是 fulfilled 状态,\n\t\t\t\t\t\t// 则 `promise2` 必须是 fulfilled 状态, 并且它的 value 和 promise1 一样\n\t\t\t\t\t\trs(this[_value]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// 2.2.1.2 如果 `onRejected` 不是一个函数, 则它必须被忽略\n\t\t\t\t\t// 2.2.3 如果 `onRejected` 是一个函数\n\t\t\t\t\tif (typeof onRejected === 'function') {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tconst rst = onRejected.call(undefined, this[_value]);\n\t\t\t\t\t\t\t// 2.2.7.1. 如果 `onFulfilled` 或 `onRejected` 返回一个 value `x`,\n\t\t\t\t\t\t\t// 则运行 Promise 解析处理程序(Promise Resolution Procedure) `[[Resolve]](promise2, x)`\n\t\t\t\t\t\t\trs(rst);\n\t\t\t\t\t\t} catch (err) {\n\t\t\t\t\t\t\trj(err);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// 2.2.7.4. 如果 `onRejected` 不是一个函数并且 `promise1` 是 rejected 状态,\n\t\t\t\t\t\t// 则 `promise2` 必须是 rejected 状态, 并且它的 reason 和 `promise1` 一样\n\t\t\t\t\t\trj(this[_value]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\t\t\t// 如果不是pending, 就立即通知还在队列中未执行的onFulfilled或onRejected\n\t\t\tif (this[_status] !== PStatus.pending) {\n\t\t\t\tthis[_notify]();\n\t\t\t}\n\t\t});\n\t}\n}\n\n// 为了跑测试暴露出来\nexport const resolve = MPromise[_resolve];\n\n// 为了跑测试暴露出来\nexport function reject(promise: MPromise<any>, reason: any) {\n\tpromise[setValueAndStatus](reason, PStatus.rejected);\n}\n"],"names":["runAsync","fn","process","nextTick","setTimeout","_status","Symbol","_value","_subs","_notify","_depend","_resolve","setValueAndStatus","MPromise","constructor","revealing","called","resolve_","val","reject_","err","promise","x","TypeError","status","Object","prototype","toString","call","then","resolvePromise","y","rejectPromise","r","resolve","rs","reject","rj","value","cb","push","length","shift","onFulfilled","onRejected","rst","reason"],"mappings":"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"}